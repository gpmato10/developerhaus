#summary 토비의 스프링, 2부 선택 - 10장 IoC 컨테이너와 DI

<wiki:toc max_depth="2" />

= 정리 =

== 10.1 IoC 컨테이터: 빈 팩토리와 애플리케이션 컨텍스트 ==

=== IoC컨테이너 정의 ===
 * 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 컨테이너가 담당
 * 오브젝트의 제어권을 컨테이너가 가지고 있어 IoC라 부름
 * 스프링 컨테이너를 Ioc컨테이너라고도 함
 * 스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고 부르기도함

 {{{
  public interface ApplicationContext extends ListableBeanFactory,
  HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher,
  ResourcePatternResolver {
 }}}

 * 스프링의 빈 팩토리와 애플리케이션 컨텍스트는 각각 기능을 대표하는 BeanFactory와 ApplicationContext라는 두 개의 인터페이스로 정의
 * 스프링 컨테이너 또는 IoC 컨테이너라고 말하는 것은 바로 이 ApplicationContext 인터페이스를 구현한 클래스의 오브젝트

=== IoC컨테이너를 이용해 애플리케이션 만들기 ===

{{{
  StaticApplicationContext ac = new StaticApplicationContext();
}}}

 * ApplicationContext 인터페이스를 구현한 클래스인 StaticApplicationContextdml 오브젝트 생성
 * 본격적인 IoC 컨테이너로서 동작하려면 POJO클래스와 설정 메타정보 필요

==== POJO 클래스 ====
 * POJO는 특정 기술과 스펙에서 독립적일뿐더러 의존관계에 있는 다른 POJO와 느슨한 결합을 갖도록 만듬.

==== 설정 메타정보 ====
 * IoC 컨테이너의 가장 기초적인 역할은 오브젝트를 생성하고 이를 관리
 * 스프링 컨테이너가 관리하는 이런 오브젝트는 빈이라 부름 
 * 스프링의 설정 메타정보는 XML 파일이 아님
 * 스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보
 * 애플리케이션 컨텍스트는 BeanDefinition으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업 수행
 * 스프링의 메타정보는 특정한 파일 포맷이나 형식에 종속되지 않음 
 * 원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 BeanDefinition 오브젝트로 변환해주는 BeanDefinitionReader있으면 됨

 * 스프링 IoC컨테이너는 각 빈에 대한 정보를 담은 설정 메타정보를 읽어들인 뒤에 이를 참고해서 빈 오브젝트를 생성하고 프로퍼티나 
생성자를 통해 의존 오브젝트를 주입해주는 DI작업을 수행. 
 * DI를 연결되는 오브젝트들이 모여서 하나의 애플리케이션을 구성하고 동작
 * 스프링 애플리케이션이란 POJO 클래스와 설정 메타정보를 이용해 IoC 컨테이너가 만들어주는 오브젝트의 조합

{{{
StaticApplicationContext ac = new StaticApplicationContext();
ac.registerSingleton("hello1", Hello.class);

Hello hello1 = ac.getBean("hello1", Hello.class);
assertThat(hello1, is(notNullValue()));
}}}
 * StaticApplicationContext는 코드에 의해 설정 메타정보를 등록하는 기능을 제공하는 애플리케이션 컨텍스트

{{{
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
}}}

 * BeanDefinition타입의 설정 메타정보를 만들어서 IoC 컨테이너에 등록하는 방법
 * RootBeanDefinition은 가장 기본적인 BeanDefinition 인터페이스 구현클래스

{{{
 Hello hello2 = ac.getBean("hello2", Hello.class);
 assertThat(hello2.sayHello(), is("Hello Spring"));
 
 assertThat(hello1, is(not(hello2)));
 assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(2));
}}}

 * 빈은 오브젝트 단위로 등록되고 만들어지기 때문에 같은 클래스 타입이더라도 두 개를 등록하면 서로 다른 빈 오브젝트가 생성

==== StaticApplicationContext ====
 * 코드를 통해 빈 메타정보를 등록하기 위해 사용
 * 스프링의 기능에 대한 학습 테스트를 만들 때를 제외하면 실제로 사용되지 않음

==== GenericApplicationContext ====
 * 가장 일반적인 애플리케이션 컨텍스트의 구현 클래스 
 * StaticApplicationContext와는 다르게 XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용

 {{{
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Spring" />
        <property name="printer" ref="printer" />
   </bean>

   <bean id="printer" class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
 }}}
 * XML로 만든 빈 설정 메타정보
{{{
 @Test
 public void genericApplicationContext() {
	GenericApplicationContext ac = new GenericApplicationContext();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ac);
	reader.loadBeanDefinitions("springbook/learningtest/spring/ioc/genericApplicationContext.xml");

        ac.refresh();

	Hello hello = ac.getBean("hello", Hello.class);   
        hello.print();

	assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}}}
 * XmlBeanDefinitionReader는 스프링의 리소스 로더를 이용해 XML 내용을 읽어옴
 * 스프링을 이용하면서 GenericApplicationContext를 직접 이용할 일은 거의 없음(코드에서 직접 만들고 초기화하지 않을 뿐이지 실제로 자주 사용)
 * 스프링의 JUnit 테스트는 테스트 내에서 사용할 수 있도록 애플리케이션 컨텍스트를 자동으로 만들어주는데 이때 생성되는 애플리케이션 컨텍스트가 바로 GenericApplicationContext

{{{
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loactions = "/test-applicationContext.xml")
public class UserServiceTest {
 @Autowired ApplicationContext applicationContext;
 ...
}}}
 * 테스트가 실행되면서 GenericApplicationContext가 생성과 동시에 XML 파일을 읽어오고 초기화까지 수행

==== GenericXmlApplicationContext ====
 * GenericApplicationContext 와 XmlBeanDefinitionReader 클래스가 결합된 형태
 * GenericXmlApplicationContext는 XmlBeanDefinitionReader를 내장하고 있기 때문에 XML 파일을 읽어들이고 refresh()를 통해 초기화하는 것까지 한 줄로 끝냄

{{{
GenericApplicationContext ac = new GenericXmlApplicationContext("springbook/learningtest/spring/ioc/genericApplicationContext.xml");

Hello hello = ac.getBean("hello", Hello.class);
...
}}}

==== WebApplicationContext ====

 * 스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트
 * 이름 그대로 웹 환경에서 사용할 때 필요한 기능이 추가된 애플리케이션 컨텍스트
 * XML 설정파일을 사용하도록 만들어진 XmlWebApplicationContext가 가장 많이 사용
 * 스프링 IoC 컨테이너는 빈 설정 메타정보를 이용해 빈 오브젝트를 만들고 DI작업을 수행
 * 이것만으로는 애플리케이션이 동작하지 않고 어디에선가 특정 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작시킴 

=== IoC 컨테이너 계층구조 ===
 * 모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있음 (이를 이용해 트리구조의 컨텍스트 계층을 만들 수 있음)
 * 계층구조 안의 코든 컨텍스트는 각자 독립적인 설정정보를 이용해 빈 오브젝트를 만들고 관리
 * 각자 독립적으로 자신이 관리하는 빈을 갖고 있긴 하지만 DI를 위해 빈을 찾을때는 부모 애플리케이션 컨텍스트의 빈까지 검색
 * 자신이 관리하는 빈 중에서 필요한 빈을 찾아보고 없으면 부모 컨텍스트에게 빈을 찾아달라고 요청
 * 부모 컨텍스트에서도 없으면 부모 컨텍스트의 부모 컨텍스트에게 까지 다시요청하고 이렇게 계층구조를 따라 가장 위에 존재하는 루트 컨텍스트까지 요청이 전달
 * 중요한건 부모 컨텍스트에게만 빈 검색을 요청하지 자식, 형제 컨텍스트에는 요청하지 않음
 * 검색 순서는 자신이 먼저이고 다음 직계 부모 순서
 * 부모 컨텍스트와 같은 이름의 빈을 자신이 정의해서 갖고 있다면 자신것이 우선

{{{
   <bean id="printer" class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
   
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Parent" />
        <property name="printer" ref="printer" />
   </bean>

}}}
 * 부모(루트) 컨텍스트가 사용하는 설정파일

{{{
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Child" />
        <property name="printer" ref="printer" />
   </bean>
}}} 
 * 자식 컨텍스트가 사용하는 설정파일

{{{
 ApplicationContext parent = new GenericXmlApplicationContext(basePath + "parentContext.xml");
}}}
 * 부모 컨텍스트는 더 이상 상위에 부모 컨텍스트가 존재하지 않는 루트 컨텍스트
 * 루트컨텍스트는 반드시 스스로 완전한 빈 의존관계를 보장(자신 외에는 다른 데서 필요한 빈을 찾을 방법이 없기 때문)

{{{
 GenericApplicationContext child = new GenericApplicationContext(parent);
}}}
 * 애플리케이션 컨텍스트를 생성할 때 앞에서 만든 parent를 부모 컨텍스트로 지정

{{{
 XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(child);
 reader.loadBeanDefinitions(basePath + "childContext.xml");
 child.refresh();
}}}
 * 자식 컨텍스트가 사용할 설정정보를 읽어들이고 초기화 
 * 설정 메타정보를 읽고 refresh() 해주면 컨텍스트를 초기화하면서 DI를 진행
 * 이때 child 컨텍스트에 필요한 빈이 존재하지 않을 경우 부모 컨텍스트에게 빈검색을 요청 

=== 웹 애플리케이션의 IoC 컨테이너 구성 ===

 * 스프링에서는 보통 독립적으로 배치 가능한 웹 모듈 형태로 애플리케이션을 배포
 * 하나의 웹 애플리케이션은 여러 개의 서블릿을 가질 수 있음
 * 최근에는 많은 웹 요청을 한번에 받을 수 있는 대표 서블릿을 등록해두고 공통적인 선행 작업을 수행하게 한 후에 각 요청의 기능을 담당하는 핸들러라고 불리는 클래스를 호출하는 방식으로 개발
 * 몇 개의 서블릿이 중앙집중식으로 모든 요청을 다 받아서 처리하는 이런 방식을 프론트 컨트롤러 패턴이라 함
 * 스프링 웹 애플리케이션에 사용되는 서블릿의 숫자는 하나이거나 많아야 두셋 정도
 * 스프링 애플리케이션의 요청을 처리하는 서블릿 안에서 만들어지는 것과 웹 애플리케이션 레벨에서 만들어지는 두가지 방식으로 웹 애플리케이션 안에서 동작하는 IoC컨테이너가 만들어짐

==== 웹 애플리케이션의 컨텍스트 계층구조 ====

 * 웹 애플리케이션 레벨에 등로되는 컨테이너는 보통 루트 웹 애플리케이션 컨텍스트라 불림
 * 루트 웹 애플리케이션 컨텍스트는 서블릿 레벨에 등록되는 컨테이너들의 부모 컨테이너가 되고 최상단에 위치한 루트 컨텍스트 
 * 웹 애플리케이션에는 하나 이상의 스프링 애플리케이션의 프론트 컨트롤러 역할을 하는 서블릿이 등록될 수 있음
 * 이런 경우 각 서블릿이 공유하게 되는 공통적인 빈들이 있고 이런 빈들을 웹 애플리케이션 레벨의 컨텍스트에 등록(공통되는 빈듯이 서블릿별로 중복돼서 생성되는 걸 방지)
 

 * 서블릿 A와 서블릿 B는 각각 자신의 전용 애플리케이션을 갖고 있음
 * 동시에 두 컨텍스트가 공유해서 사용하는 빈을 담아놓을 수 있는 별도의 컨텍스트가 존재
 * 이 컨텍스트는 각 서블릿에 존재하는 컨텍스트의 부모 컨텍스트(또 최상단에 있으므로 계층구조로 볼때는 루트 컨텍스트)
 * 스플링에서 애플리케이션 컨텍스트 계층구조가 사용되는 경우 

 * 일반적으로는 스프링의 애플리케이션 컨텍스트를 가지면서 프론트 컨트롤러 역할을 하는 서블릿은 하나만 만들어 사용 

 * 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분
 * 스플링을 이용하는 웹 애플리케이션이라고 해서 반드시 스프링이 제공하는 웹 기술을 사용해야는 건 아님
  

 * 스프링은 웹 애플리케이션마다 하나씩 존재하는 서블릿 컨텍스트를 통해 루트 애플리케이션 컨텍스트에 접근할 수있는 방법을 제공

 {{{
   WebApplicationContextUtils.getWebApplicationContext(SevletContext sc)
 }}}

 * 스프링의 간단한 유틸리티 메소드를 이용하면스프링 밖의 어디서라도 웹 애플리케이션의 루트 애플리케이션 컨텍스트를 얻을 수 있음(getBean() 메소드를 사용하면 루트 컨텍스트의 빈을 가져와 쓸수 있음)
 * SevletContext는 웹 애플리케이션마다 하나씩 만들어지는 것으로, 서블릿의 런타임 환경정보를 담고있음

==== 웹 애플리케이션의 컨텍스트 구성방법 ====

 * 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층 구조 
  - 가장 많이 사용되는 기본적인 구성 방법
  - 스프링 웹 기술을 사용하는 경우 웹 관련 빈들은 서블릿의 컨텍스트에 두고 나머지는 루트 애플리케이션 컨텍스트에 등록
  
 * 루트 애플리케이션 컨텍스트 단일구조
  - 스프링 웹 기술을 사용하지 않고 서드파티 웹 프레임워크나 서비스 엔진만을 사용해서 프리젠테이션 계층을 만든다면 스프링 서블릿을 둘 이유 없음(서블릿의 애플리케이션 컨텍스트 사용하지 않음)
  
 * 서블릿 컨텍스트 단일구조
  - 스프링 웹 기술을 사용하면서 스프링 외의 프레임워크나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아니라면 루트 애플리케이션 생략 가능
  - 서블릿에서 만들어지는 컨텍스트에 모든 빈을 등록

==== 루트 애플리케이션 컨텍스트 등록 ====
 * 이벤트 리스너를 이용해 루트 웹 애플리케이션 컨텍스르르 등록
 * 스프링은 웹 애플리케이션의 시작과 종료 시 발생하는 이벤트를 처리하는 리스너인 ServletContextLister를 이용
 * 웹 애플리케이션이 시작될 때 루트 애플리케이션 컨텍스트를 만들어 초기화하고, 웹 애플리케이션이 종료될 때 컨텍스트를 함께 종료하는 기능을 가진 리스너를 만듬(스프링은 ContextLoaderListener를 제공)

 {{{
  <listner>
	<listner-class>org.springframework.web.context.ContextLoderListener
     </listner-class>
  </listner>
 }}}
 
 * 애플리케이션 컨텍스트 클래스 : XmlWebApplicationContext
 * XML 설정파일 위치 : /WEB-INF/applicationContext.xml
 * 컨텍스트 클래스와 설정파일 위치는 서블릿 컨텍스트 파라미터를 선언해서 변경가능

 {{{
   <context-param>
	<param-name>contextConfigLocation</param-name>
 	<param-value>
  		/WEB-INF/daoContext.xml
 		/WEB-INF/applicationContext.xml
   	</param-value>
   </context-param>
 }}}

 * 디폴트 설정 파일 위치인 /WEB-INF/applicationContext.xml은 무시되고 파라미터로 제공된 설정파일을 사용

 {{{
	<param-value>classpath:applicationContext.xml</param-value>
 }}}

 * 리소스 로더가 사요아는 접두어를 사용해서 표현 할 수 있음
 
 {{{
   <context-param>
	<param-name>contextClass</param-name>
 	<param-value>org.springframework.web.context.support.AnnoationConfigWebApplicationContext
   	</param-value>
   </context-param>
 }}}

 * 애플리케이션 컨텍스트 구현 클래스 변경
 * 여기서 사용될 컨텍스트는 반드시 WebApplicationContext 인터페이스를 구현

== 10.2 IoC/DI를 위한 빈 설정 메타정보 작성 ==

 * IoC 컨테이너
  * 코드를 대신해 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 역할을 한다.
  * 빈 설정 메타정보를 통해 빈의 클래스와 이름을 제공 받아 자신이 만들 오브젝트를 파악한다.
   * 빈 설정 메타정보는 파일이나 애노테이션 같은 리소스로부터 전용 리더를 통해 BeanDefinition 타입의 오브젝트로 변환되고 이 정보를 IoC 컨테이너가 활용한다.

=== 10.2.1 빈 설정 메타정보 ===
 * BeanDefinition
  * beanClassName(필수) : 빈 오브젝트의 클래스 이름. 빈 오브젝트는 이 클래스의 인스턴스가 된다.
  * parentName : 빈 메타정보를 상속받을 부모 BeanDefinition의 이름. 빈의 메타정보는 계층구조로 상속할 수 있다.
  * factoryBeanName : 팩토리 역할을 하는 빈을 이용해 빈 오브젝트를 생성하는 경우에 팩토리 빈의 이름을 지정한다.
  * factoryMethodName : 다른 빈 또는 클래스의 메소드를 통해 빈 오브젝트를 생성하는 경우 그 메소드 이름을 지정한다.
  * scope : 빈 오브젝트의 생명주기를 결정하는 스코프를 지정한다. 크게 싱글톤과 비싱글톤 스코프로 구분할 수 있다.(디폴트 = 싱글톤)
  * lazyInit 빈 오브젝트의 생성을 최대한 지연할 것인지를 지정한다. 이 값이 true이면 컨테이너는 빈 오브젝트의 생성을 꼭 필요한 시점까지 미룬다.(디폴트 = false)
  * dependsOn : 먼저 만들어져야 하는 빈을 지정할 수 있다. 빈 오브젝트의 생성 순서가 보장돼야 하는 경우 이용한다. 하나 이상의 빈 이름을 지정할 수 있다.
  * autowireCandidate : 명시적인 설정이 없어도 미리 정해진 규칙을 가지고 자동으로 DI 후보를 결정하는 자동와이어링의 대상으로 포함시킬지의 여부(디폴트 = true)
  * primary : 자동와이어링 작업 중에 DI 대상 후보가 여러 개가 발생하는 경우가 있다. 이때 최종 선택의 우선권을 부여할지 여부. primary가 지정된 빈이 없이 여러 개의 후보가 존재하면 자동와이어링 예외가 발생한다.(디폴트 = false)
  * abstract : 메타정보 상속에만 사용할 추상 빈으로 만들지의 여부. 추상 빈이 되면 그 자체는 오브젝트가 생성되지 않고 다른 빈의 부모를 빈으로만 사용된다.(디폴트 = false)
  * autowireMode : 오토와이어링 전략. 이름, 타입, 생성자, 자동인식 등의 방법이 있다.
  * dependencyCheck : 프로퍼티 값 또는 레퍼런스가 모두 설정되어 있는지를 검증하는 작업의 종류(디폴트 : 체크하지 않음)
  * initMethod : 빈이 생성되고 DI를 마친 뒤에 실행할 초기화 메소드의 이름
  * destoryMethod : 빈의 생명주기가 다 돼서 제거하기 전에 호출할 메소드의 이름
  * propertyValues : 프로퍼티의 이름과 설정 값 또는 레퍼런스. 수정자 메소드를 통한 DI 작업에서 사용한다.
  * annotationMetadata : 빈 클래스에 담긴 애노테이션과 그 애트리뷰트 값. 애노테이션을 이용하는 설정에서 활용한다.

빈은 오브젝트이기 때문에 빈을 생성하기 위해서는 클래스가 반드시 필요하다. 그렇기 때문에 위의 메타정보 항목 중에 가장 중요한 것은 클래스이름이다. 클래스 이름과 빈의 아이디 또는 이름이 있으면 간단한 빈을 정의할 수 있다.


=== 10.2.2 빈 등록 방법 ===
 빈을 등록할 때에는 보통 XML 문서, 프로퍼티 파일, 소스코드 애노테이션과 같은 외부 리소스로 빈 메타정보를 작성하고 적절한 리더나 변환기를 통해 애플리케이션 컨텍스트가 사용할 수 있는 정보로 변환해주는 방법을 사용한다.

 * XML:`<bean>` 태그
{{{
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="printer">
		<bean class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
	</property>
</bean>
}}}
  * `<beans>` 엘리먼트 하위에 `<bean>` 태그가 존재한다.
  * 빈 설정 안에 정의하는 내부 빈(inner bean) 을 이용해 특정 빈에서 참조하는 bean을 설정할 수 있다.
 * XML:네임스페이스와 전용 태그
  * 컨텍스트가 사용하는 설정정보를 담은 빈과 애플리케이션 로직을 담은 빈이 동일하게 `<bean>` 태그를 이용해 만들어지면 구분하기가 힘들다. 또한 한눈에 빈을 등록한 의도와 의미를 파악하기 힘들다.
  * 네임스페이스와 전용 태그, 전용 애트리뷰트를 이용해 선언하면 내용이 분명하게 드러나고 선언도 깔끔해지고 애플리케이션 로직을 담은 다른 빈 설정과 혼동되지도 않는다.
  * 예 : 포인트컷
{{{
<bean id="mypointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
	<property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))" />
</bean>
}}}
{{{
<aop:pointcut id="mypointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))" />
}}}
  * 예 : 내장형 DB 선언
{{{
<jdbc:embedded-database id="embeddedDatabase" type="HSQL">
	<jdbc:script location="schema.sql" />
</jdbc:embedded-database>
}}} 
  * 예 : 커스텀 태그
{{{
<app:module id-prefix="user" class-prefix="User" package="com.mycompany.user" />
}}}
{{{
<bean id="userController" class="com.mycompany.user.UserController">
	<property name="service" ref="userService" />
</bean>
<bean id="userService" class="com.mycompany.user.UserService">
	<property name="dao" ref="userDao" />
</bean>
<bean id="userDao" class="com.mycompany.userUserDao">
</bean>
}}}
 * 자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너
  * XML 문서와 같이 한곳에 명시적으로 선언하지 않고 스프링 빈으로 등록하는 방법
  특정 애노테이션이 붙은 클래스를 찾아서 빈으로 등록해주는 방식
  * 스테레오타입(stereotype) 애노테이션 : 디폴트 필터에 적용되는 애노테이션(@Component, @Repository, @Service, @Controller)
{{{
@Component
public class AnnotatedHello {
...
}
}}}
  * 클래스 이름의 첫 글자를 소문자로 바꾼 것을 빈의 아이디로 사용한다.
  * 빈 이름 지정 방법
{{{
@Component("myAnnotatedHello")
public class AnnotatedHello {
...
}
}}}
  * 복잡한 XML 문서를 생성하거나 관리할 필요가 없어지고 그만큼 개발 속도를 향상시킬 수 있다.
  * 애플리케이션에 등록된 빈이 어떤것들인지, 그 정의는 어떻게 되는지 한눈에 파악할 수 없다.
  * 상세한 메타정보 항목을 지정할 수 없고, 클래스당 한 개 이상의 빈을 등록할 수 없다.
  * 개발 중에는 생산성을 위해 빈 스캐닝 기능을 사용해 빈을 등록하고, 운영 시점이 되면 다시 XML 형태의 빈 선언을 적용하는 것도 좋다.
  * 자동인식을 통한 빈 등록 방법
   * XML을 이용한 빈 스캐너 등록
    * XML 설정 파일에 '<context:component-scan> 태그를 넣어주면 된다.
{{{
<context:component-scan base-package="springbook.learningtest.spring.ioc.bean" />
}}}
   * 빈 스캐너를 내장한 애플리케이션 컨텍스트 사용
    * 루트 컨텍스트가 XML 대신 빈 스캐너를 이용해 빈을 등록하도록 web.xml 안에 컨텍스트 파라미터를 설정하는 예
{{{
<context-param>
	<param-name>contextClass</param-name>
	<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
</context-param>

<context-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>springbook.learningtest.spring.ioc.bean</param-value>
</context-param>
}}}
    * `<param-value>`에 하나 이상의 스캔 대상 패키지를 지정할 때에는 각 패키지 사이에 공백을 넣어준다.

빈 클래스 자동인식을 위해 @Component 외에 몇 가지 종류가 더 있는데, 계증별로 빈의 특성이나 종류를 나타내기도 하고, AOP의 적용 대상 그룹을 만들기 위해 여러가지 애노테이션을 사용한다.

 * 스테레오타입 애노테이션의 종류
|| *스테레오타입 애노테이션* || *적용 대상* ||
|| @Repository || 데이터 액세스 계층의 DAO 또는 리포지토리 클래스에 사용된다. DataAccessException 자동변환과 같은 AOP의 적용 대상을 선정하기 위해서도 사용된다. ||
|| @Service || 서비스 계층의 클래스에 사용된다. ||
|| @Controller || 프레젠테이션 계층의 MVC 컨트롤러에 사용된다. 스프링 웹 서블릿에 의해 웹 요청을 처리하는 컨트롤러 빈으로 선정된다. ||

특정 계층으로 분류하기 힘든 경우에는 @Component를 사용한다.
또한 직접 커스텀 태그를 설정할 수도 있다.
{{{
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface BusinessRule {
	String value() default "";
}
}}}

== 10.3 프로토타입과 스코프 ==


== 10.4 기타 빈 설정 메타정보 ==



= 생각하기 =