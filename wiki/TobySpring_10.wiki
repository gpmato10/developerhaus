#summary 토비의 스프링, 2부 선택 - 10장 IoC 컨테이너와 DI

<wiki:toc max_depth="2" />

= 정리 =

== 10.1 IoC 컨테이터: 빈 팩토리와 애플리케이션 컨텍스트 ==

=== IoC컨테이너 정의 ===
 * 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 컨테이너가 담당
 * 오브젝트의 제어권을 컨테이너가 가지고 있어 IoC라 부름
 * 스프링 컨테이너를 Ioc컨테이너라고도 함
 * 스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고 부르기도함

 {{{
  public interface ApplicationContext extends ListableBeanFactory,
  HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher,
  ResourcePatternResolver {
 }}}

 * 스프링의 빈 팩토리와 애플리케이션 컨텍스트는 각각 기능을 대표하는 BeanFactory와 ApplicationContext라는 두 개의 인터페이스로 정의
 * 스프링 컨테이너 또는 IoC 컨테이너라고 말하는 것은 바로 이 ApplicationContext 인터페이스를 구현한 클래스의 오브젝트

=== IoC컨테이너를 이용해 애플리케이션 만들기 ===

{{{
  StaticApplicationContext ac = new StaticApplicationContext();
}}}

 * ApplicationContext 인터페이스를 구현한 클래스인 StaticApplicationContextdml 오브젝트 생성
 * 본격적인 IoC 컨테이너로서 동작하려면 POJO클래스와 설정 메타정보 필요

==== POJO 클래스 ====
 * POJO는 특정 기술과 스펙에서 독립적일뿐더러 의존관계에 있는 다른 POJO와 느슨한 결합을 갖도록 만듬.

==== 설정 메타정보 ====
 * IoC 컨테이너의 가장 기초적인 역할은 오브젝트를 생성하고 이를 관리
 * 스프링 컨테이너가 관리하는 이런 오브젝트는 빈이라 부름 
 * 스프링의 설정 메타정보는 XML 파일이 아님
 * 스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보
 * 애플리케이션 컨텍스트는 BeanDefinition으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업 수행
 * 스프링의 메타정보는 특정한 파일 포맷이나 형식에 종속되지 않음 
 * 원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 BeanDefinition 오브젝트로 변환해주는 BeanDefinitionReader있으면 됨

 * 스프링 IoC컨테이너는 각 빈에 대한 정보를 담은 설정 메타정보를 읽어들인 뒤에 이를 참고해서 빈 오브젝트를 생성하고 프로퍼티나 
생성자를 통해 의존 오브젝트를 주입해주는 DI작업을 수행. 
 * DI를 연결되는 오브젝트들이 모여서 하나의 애플리케이션을 구성하고 동작
 * 스프링 애플리케이션이란 POJO 클래스와 설정 메타정보를 이용해 IoC 컨테이너가 만들어주는 오브젝트의 조합

{{{
StaticApplicationContext ac = new StaticApplicationContext();
ac.registerSingleton("hello1", Hello.class);

Hello hello1 = ac.getBean("hello1", Hello.class);
assertThat(hello1, is(notNullValue()));
}}}
 * StaticApplicationContext는 코드에 의해 설정 메타정보를 등록하는 기능을 제공하는 애플리케이션 컨텍스트

{{{
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
}}}

 * BeanDefinition타입의 설정 메타정보를 만들어서 IoC 컨테이너에 등록하는 방법
 * RootBeanDefinition은 가장 기본적인 BeanDefinition 인터페이스 구현클래스

{{{
 Hello hello2 = ac.getBean("hello2", Hello.class);
 assertThat(hello2.sayHello(), is("Hello Spring"));
 
 assertThat(hello1, is(not(hello2)));
 assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(2));
}}}

 * 빈은 오브젝트 단위로 등록되고 만들어지기 때문에 같은 클래스 타입이더라도 두 개를 등록하면 서로 다른 빈 오브젝트가 생성

==== StaticApplicationContext ====
 * 코드를 통해 빈 메타정보를 등록하기 위해 사용
 * 스프링의 기능에 대한 학습 테스트를 만들 때를 제외하면 실제로 사용되지 않음

==== GenericApplicationContext ====
 * 가장 일반적인 애플리케이션 컨텍스트의 구현 클래스 
 * StaticApplicationContext와는 다르게 XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용

 {{{
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Spring" />
        <property name="printer" ref="printer" />
   </bean>

   <bean id="printer" class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
 }}}
 * XML로 만든 빈 설정 메타정보
{{{
 @Test
 public void genericApplicationContext() {
	GenericApplicationContext ac = new GenericApplicationContext();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ac);
	reader.loadBeanDefinitions("springbook/learningtest/spring/ioc/genericApplicationContext.xml");

        ac.refresh();

	Hello hello = ac.getBean("hello", Hello.class);   
        hello.print();

	assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}}}
 * XmlBeanDefinitionReader는 스프링의 리소스 로더를 이용해 XML 내용을 읽어옴
 * 스프링을 이용하면서 GenericApplicationContext를 직접 이용할 일은 거의 없음(코드에서 직접 만들고 초기화하지 않을 뿐이지 실제로 자주 사용)
 * 스프링의 JUnit 테스트는 테스트 내에서 사용할 수 있도록 애플리케이션 컨텍스트를 자동으로 만들어주는데 이때 생성되는 애플리케이션 컨텍스트가 바로 GenericApplicationContext

{{{
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loactions = "/test-applicationContext.xml")
public class UserServiceTest {
 @Autowired ApplicationContext applicationContext;
 ...
}}}
 * 테스트가 실행되면서 GenericApplicationContext가 생성과 동시에 XML 파일을 읽어오고 초기화까지 수행

==== GenericXmlApplicationContext ====
 * GenericApplicationContext 와 XmlBeanDefinitionReader 클래스가 결합된 형태
 * GenericXmlApplicationContext는 XmlBeanDefinitionReader를 내장하고 있기 때문에 XML 파일을 읽어들이고 refresh()를 통해 초기화하는 것까지 한 줄로 끝냄

{{{
GenericApplicationContext ac = new GenericXmlApplicationContext("springbook/learningtest/spring/ioc/genericApplicationContext.xml");

Hello hello = ac.getBean("hello", Hello.class);
...
}}}

==== WebApplicationContext ====

 * 스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트
 * 이름 그대로 웹 환경에서 사용할 때 필요한 기능이 추가된 애플리케이션 컨텍스트
 * XML 설정파일을 사용하도록 만들어진 XmlWebApplicationContext가 가장 많이 사용
 * 스프링 IoC 컨테이너는 빈 설정 메타정보를 이용해 빈 오브젝트를 만들고 DI작업을 수행
 * 이것만으로는 애플리케이션이 동작하지 않고 어디에선가 특정 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작시킴 

=== IoC 컨테이너 계층구조 ===
 * 모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있음 (이를 이용해 트리구조의 컨텍스트 계층을 만들 수 있음)
 * 계층구조 안의 코든 컨텍스트는 각자 독립적인 설정정보를 이용해 빈 오브젝트를 만들고 관리
 * 각자 독립적으로 자신이 관리하는 빈을 갖고 있긴 하지만 DI를 위해 빈을 찾을때는 부모 애플리케이션 컨텍스트의 빈까지 검색
 * 자신이 관리하는 빈 중에서 필요한 빈을 찾아보고 없으면 부모 컨텍스트에게 빈을 찾아달라고 요청
 * 부모 컨텍스트에서도 없으면 부모 컨텍스트의 부모 컨텍스트에게 까지 다시요청하고 이렇게 계층구조를 따라 가장 위에 존재하는 루트 컨텍스트까지 요청이 전달
 * 중요한건 부모 컨텍스트에게만 빈 검색을 요청하지 자식, 형제 컨텍스트에는 요청하지 않음
 * 검색 순서는 자신이 먼저이고 다음 직계 부모 순서
 * 부모 컨텍스트와 같은 이름의 빈을 자신이 정의해서 갖고 있다면 자신것이 우선

{{{
   <bean id="printer" class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
   
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Parent" />
        <property name="printer" ref="printer" />
   </bean>

}}}
 * 부모(루트) 컨텍스트가 사용하는 설정파일

{{{
   <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	<property name="name" value="Child" />
        <property name="printer" ref="printer" />
   </bean>
}}} 
 * 자식 컨텍스트가 사용하는 설정파일

{{{
 ApplicationContext parent = new GenericXmlApplicationContext(basePath + "parentContext.xml");
}}}
 * 부모 컨텍스트는 더 이상 상위에 부모 컨텍스트가 존재하지 않는 루트 컨텍스트
 * 루트컨텍스트는 반드시 스스로 완전한 빈 의존관계를 보장(자신 외에는 다른 데서 필요한 빈을 찾을 방법이 없기 때문)

{{{
 GenericApplicationContext child = new GenericApplicationContext(parent);
}}}
 * 애플리케이션 컨텍스트를 생성할 때 앞에서 만든 parent를 부모 컨텍스트로 지정 
=== IoC컨테이너의 종류와 사용 방법 ===



== 10.2 IoC/DI를 위한 빈 설정 메타정보 작성 ==



== 10.3 프로토타입과 스코프 ==


== 10.4 기타 빈 설정 메타정보 ==



= 생각하기 =